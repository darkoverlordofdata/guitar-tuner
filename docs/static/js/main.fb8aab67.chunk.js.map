{"version":3,"sources":["PitchNode.js","setupAudio.js","App.js","serviceWorker.js","index.js"],"names":["PitchNode","wasmBytes","onPitchDetectedCallback","numAudioSamplesPerAnalysis","this","port","onmessage","event","data","postMessage","type","err","console","log","sampleRate","context","pitch","AudioWorkletNode","getWebAudioMediaStream","a","window","navigator","mediaDevices","Error","getUserMedia","audio","video","result","name","setupAudio","mediaStream","AudioContext","audioSource","createMediaStreamSource","fetch","response","arrayBuffer","processorUrl","audioWorklet","addModule","message","node","init","connect","destination","PitchReadout","running","latestPitch","units","title","value","toFixed","minValue","maxValue","majorTicks","minorTicks","strokeTicks","highlights","width","height","AudioRecorderControl","React","useState","undefined","setAudio","setRunning","setLatestPitch","onClick","suspend","state","resume","disabled","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.fb8aab67.chunk.js","sourcesContent":["export default class PitchNode extends AudioWorkletNode {\n  /**\n   * Initialize the Audio processor by sending the fetched WebAssembly module to\n   * the processor worklet.\n   *\n   * @param {ArrayBuffer} wasmBytes Sequence of bytes representing the entire\n   * WASM module that will handle pitch detection.\n   * @param {number} numAudioSamplesPerAnalysis Number of audio samples used\n   * for each analysis. Must be a power of 2.\n   */\n  init(wasmBytes, onPitchDetectedCallback, numAudioSamplesPerAnalysis) {\n    this.onPitchDetectedCallback = onPitchDetectedCallback;\n    this.numAudioSamplesPerAnalysis = numAudioSamplesPerAnalysis;\n\n    // Listen to messages sent from the audio processor.\n    this.port.onmessage = (event) => this.onmessage(event.data);\n\n    this.port.postMessage({\n      type: \"send-wasm-module\",\n      wasmBytes,\n    });\n  }\n\n  // Handle an uncaught exception thrown in the PitchProcessor.\n  onprocessorerror(err) {\n    console.log(\n      `An error from AudioWorkletProcessor.process() occurred: ${err}`\n    );\n  };\n\n  onmessage(event) {\n    if (event.type === 'wasm-module-loaded') {\n      // The Wasm module was successfully sent to the PitchProcessor running on the\n      // AudioWorklet thread and compiled. This is our cue to configure the pitch\n      // detector.\n      this.port.postMessage({\n        type: \"init-detector\",\n        sampleRate: this.context.sampleRate,\n        numAudioSamplesPerAnalysis: this.numAudioSamplesPerAnalysis\n      });\n    } else if (event.type === \"pitch\") {\n      // A pitch was detected. Invoke our callback which will result in the UI updating.\n      this.onPitchDetectedCallback(event.pitch);\n    }\n  }\n}\n","import PitchNode from \"./PitchNode\";\n\nasync function getWebAudioMediaStream() {\n  if (!window.navigator.mediaDevices) {\n    throw new Error(\n      \"This browser does not support web audio or it is not enabled.\"\n    );\n  }\n\n  try {\n    const result = await window.navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    return result;\n  } catch (e) {\n    switch (e.name) {\n      case \"NotAllowedError\":\n        throw new Error(\n          \"A recording device was found but has been disallowed for this application. Enable the device in the browser's settings.\"\n        );\n\n      case \"NotFoundError\":\n        throw new Error(\n          \"No recording device was found. Please attach a microphone and click Retry.\"\n        );\n\n      default:\n        throw e;\n    }\n  }\n}\n\nexport async function setupAudio(onPitchDetectedCallback) {\n  // Get the browser's audio. Awaits user \"allowing\" it for the current tab.\n  const mediaStream = await getWebAudioMediaStream();\n\n  const context = new window.AudioContext();\n  const audioSource = context.createMediaStreamSource(mediaStream);\n\n  let node;\n\n  try {\n    // Fetch the WebAssembly module that performs pitch detection.\n    const response = await window.fetch(\"wasm-audio/wasm_audio_bg.wasm\");\n    const wasmBytes = await response.arrayBuffer();\n\n    // Add our audio processor worklet to the context.\n    const processorUrl = \"PitchProcessor.js\";\n    try {\n      await context.audioWorklet.addModule(processorUrl);\n    } catch (e) {\n      throw new Error(\n        `Failed to load audio analyzer worklet at url: ${processorUrl}. Further info: ${e.message}`\n      );\n    }\n\n    // Create the AudioWorkletNode which enables the main Javascript thread to\n    // communicate with the audio processor (which runs in a Worklet).\n    node = new PitchNode(context, \"PitchProcessor\");\n\n    // numAudioSamplesPerAnalysis specifies the number of consecutive audio samples that\n    // the pitch detection algorithm calculates for each unit of work. Larger values tend\n    // to produce slightly more accurate results but are more expensive to compute and\n    // can lead to notes being missed in faster passages i.e. where the music note is\n    // changing rapidly. 1024 is usually a good balance between efficiency and accuracy\n    // for music analysis.\n    // const numAudioSamplesPerAnalysis = 1024;\n    const numAudioSamplesPerAnalysis = 1024 * 2;\n\n    // Send the Wasm module to the audio node which in turn passes it to the\n    // processor running in the Worklet thread. Also, pass any configuration\n    // parameters for the Wasm detection algorithm.\n    node.init(wasmBytes, onPitchDetectedCallback, numAudioSamplesPerAnalysis);\n\n    // Connect the audio source (microphone output) to our analysis node.\n    audioSource.connect(node);\n\n    // Connect our analysis node to the output. Required even though we do not\n    // output any audio. Allows further downstream audio processing or output to\n    // occur.\n    node.connect(context.destination);\n  } catch (err) {\n    throw new Error(\n      `Failed to load audio analyzer WASM module. Further info: ${err.message}`\n    );\n  }\n\n  return { context, node };\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport { setupAudio } from \"./setupAudio\";\nimport { RadialGauge } from \"react-canvas-gauges\"\n\nfunction PitchReadout({ running, latestPitch }) {\n  return (\n    <RadialGauge\n      units='Hz'\n      title='Frequency'\n      value=      {latestPitch\n        ? `${latestPitch.toFixed(1)}`\n        : running\n        ? '80'\n        : '0'}\n      minValue={77}\n      maxValue={87}\n      majorTicks={['77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87']}\n      minorTicks={2}\n      strokeTicks={true}\n      highlights={[\n        {\"from\": 77, \"to\": 82, \"color\": \"rgba(0,0, 255, .3)\"},\n        {\"from\": 82, \"to\": 87, \"color\": \"rgba(255, 0, 0, .3)\"}\n      ]}\n      width={400}\n      height={400}\n      // ticksAngle={225}\n      // startAngle={67.5}\n      // colorMajorTicks=\"#ddd\"\n      // colorMinorTicks=\"#ddd\"\n      // colorTitle=\"#eee\"\n      // colorUnits=\"#ccc\"\n      // colorNumbers=\"#eee\"\n      // colorPlate=\"#222\"\n      // borderShadowWidth=\"0\"\n      // borders={true}\n      // needleType=\"arrow\"\n      // needleWidth={2}\n      // needleCircleSize={7}\n      // needleCircleOuter={true}\n      // needleCircleInner={false}\n      // animationDuration={1500}\n      // animationRule=\"linear\"\n      // colorBorderOuter=\"#333\"\n      // colorBorderOuter-end=\"#111\"\n      // colorBorderMiddle=\"#222\"\n      // colorBorderMiddle-end=\"#111\"\n      // colorBorderInner=\"#111\"\n      // colorBorderInner-end=\"#333\"\n      // colorNeedleShadowDown=\"#333\"\n      // colorNeedleCircleOuter=\"#333\"\n      // colorNeedleCircleOuter-end=\"#111\"\n      // colorNeedleCircleInner=\"#111\"\n      // colorNeedleCircleInner-end=\"#222\"\n      // valueBoxBorderRadius=\"0\"\n      // colorValueBoxRect=\"#222\"\n      // colorValueBoxRect-end=\"#333\"\n      // fontValue=\"Led\"\n      // fontNumbers=\"Led\"\n      // fontTitle=\"Led\"\n      // fontUnits=\"Led\"\n      \n\n    ></RadialGauge>    \n  );\n}\n\nfunction AudioRecorderControl() {\n  const [audio, setAudio] = React.useState(undefined);\n  const [running, setRunning] = React.useState(false);\n  const [latestPitch, setLatestPitch] = React.useState(undefined);\n\n  // Initial state. Initialize the web audio once a user gesture on the page\n  // has been registered.\n  if (!audio) {\n    return (\n      <button\n        onClick={async () => {\n          setAudio(await setupAudio(setLatestPitch));\n          setRunning(true);\n        }}\n      >\n        Start listening\n      </button>\n    );\n  }\n\n  // Audio already initialized. Suspend / resume based on its current state.\n  const { context } = audio;\n  return (\n    <div>\n      <button\n        onClick={async () => {\n          if (running) {\n            await context.suspend();\n            setRunning(context.state === \"running\");\n          } else {\n            await context.resume();\n            setRunning(context.state === \"running\");\n          }\n        }}\n        disabled={context.state !== \"running\" && context.state !== \"suspended\"}\n      >\n        {running ? \"Pause\" : \"Resume\"}\n      </button><div/>\n      <PitchReadout running={running} latestPitch={latestPitch} />\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      {/* <header className=\"App-header\">\n        Wasm Audio Tutorial\n      </header> */}\n      <div className=\"App-content\">\n        <AudioRecorderControl />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}