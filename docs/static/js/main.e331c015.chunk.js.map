{"version":3,"sources":["PitchNode.js","setupAudio.js","components/StringSelector.js","components/PitchReadout.js","App.js","serviceWorker.js","index.js"],"names":["PitchNode","wasmBytes","onPitchDetectedCallback","numAudioSamplesPerAnalysis","this","port","onmessage","event","data","postMessage","type","err","console","log","sampleRate","context","pitch","AudioWorkletNode","getWebAudioMediaStream","a","window","navigator","mediaDevices","Error","getUserMedia","audio","video","result","name","setupAudio","mediaStream","AudioContext","audioSource","createMediaStreamSource","fetch","response","arrayBuffer","processorUrl","audioWorklet","addModule","message","node","init","connect","destination","StringSelector","React","useState","selectedValue","setSelectedValue","handleChange","alert","target","value","FormControlLabel","control","Radio","checked","onChange","inputProps","label","labelPlacement","color","PitchReadout","units","title","props","latestPitch","toFixed","running","minValue","maxValue","majorTicks","minorTicks","strokeTicks","highlights","width","height","Component","AudioRecorderControl","undefined","setAudio","setRunning","setLatestPitch","onClick","Grid","container","direction","instrument","tuning","Button","suspend","state","resume","disabled","App","className","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.e331c015.chunk.js","sourcesContent":["export default class PitchNode extends AudioWorkletNode {\n  /**\n   * Initialize the Audio processor by sending the fetched WebAssembly module to\n   * the processor worklet.\n   *\n   * @param {ArrayBuffer} wasmBytes Sequence of bytes representing the entire\n   * WASM module that will handle pitch detection.\n   * @param {number} numAudioSamplesPerAnalysis Number of audio samples used\n   * for each analysis. Must be a power of 2.\n   */\n  init(wasmBytes, onPitchDetectedCallback, numAudioSamplesPerAnalysis) {\n    this.onPitchDetectedCallback = onPitchDetectedCallback;\n    this.numAudioSamplesPerAnalysis = numAudioSamplesPerAnalysis;\n\n    // Listen to messages sent from the audio processor.\n    this.port.onmessage = (event) => this.onmessage(event.data);\n\n    this.port.postMessage({\n      type: \"send-wasm-module\",\n      wasmBytes,\n    });\n  }\n\n  // Handle an uncaught exception thrown in the PitchProcessor.\n  onprocessorerror(err) {\n    console.log(\n      `An error from AudioWorkletProcessor.process() occurred: ${err}`\n    );\n  };\n\n  onmessage(event) {\n    if (event.type === 'wasm-module-loaded') {\n      // The Wasm module was successfully sent to the PitchProcessor running on the\n      // AudioWorklet thread and compiled. This is our cue to configure the pitch\n      // detector.\n      this.port.postMessage({\n        type: \"init-detector\",\n        sampleRate: this.context.sampleRate,\n        numAudioSamplesPerAnalysis: this.numAudioSamplesPerAnalysis\n      });\n    } else if (event.type === \"pitch\") {\n      // A pitch was detected. Invoke our callback which will result in the UI updating.\n      this.onPitchDetectedCallback(event.pitch);\n    }\n  }\n}\n","import PitchNode from \"./PitchNode\";\n\nasync function getWebAudioMediaStream() {\n  if (!window.navigator.mediaDevices) {\n    throw new Error(\n      \"This browser does not support web audio or it is not enabled.\"\n    );\n  }\n\n  try {\n    const result = await window.navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false,\n    });\n\n    return result;\n  } catch (e) {\n    switch (e.name) {\n      case \"NotAllowedError\":\n        throw new Error(\n          \"A recording device was found but has been disallowed for this application. Enable the device in the browser's settings.\"\n        );\n\n      case \"NotFoundError\":\n        throw new Error(\n          \"No recording device was found. Please attach a microphone and click Retry.\"\n        );\n\n      default:\n        throw e;\n    }\n  }\n}\n\nexport async function setupAudio(onPitchDetectedCallback) {\n  // Get the browser's audio. Awaits user \"allowing\" it for the current tab.\n  const mediaStream = await getWebAudioMediaStream();\n\n  const context = new window.AudioContext();\n  const audioSource = context.createMediaStreamSource(mediaStream);\n\n  let node;\n\n  try {\n    // Fetch the WebAssembly module that performs pitch detection.\n    const response = await window.fetch(\"wasm-audio/wasm_audio_bg.wasm\");\n    const wasmBytes = await response.arrayBuffer();\n\n    // Add our audio processor worklet to the context.\n    const processorUrl = \"PitchProcessor.js\";\n    try {\n      await context.audioWorklet.addModule(processorUrl);\n    } catch (e) {\n      throw new Error(\n        `Failed to load audio analyzer worklet at url: ${processorUrl}. Further info: ${e.message}`\n      );\n    }\n\n    // Create the AudioWorkletNode which enables the main Javascript thread to\n    // communicate with the audio processor (which runs in a Worklet).\n    node = new PitchNode(context, \"PitchProcessor\");\n\n    // numAudioSamplesPerAnalysis specifies the number of consecutive audio samples that\n    // the pitch detection algorithm calculates for each unit of work. Larger values tend\n    // to produce slightly more accurate results but are more expensive to compute and\n    // can lead to notes being missed in faster passages i.e. where the music note is\n    // changing rapidly. 1024 is usually a good balance between efficiency and accuracy\n    // for music analysis.\n    // const numAudioSamplesPerAnalysis = 1024;\n    const numAudioSamplesPerAnalysis = 1024 * 2;\n\n    // Send the Wasm module to the audio node which in turn passes it to the\n    // processor running in the Worklet thread. Also, pass any configuration\n    // parameters for the Wasm detection algorithm.\n    node.init(wasmBytes, onPitchDetectedCallback, numAudioSamplesPerAnalysis);\n\n    // Connect the audio source (microphone output) to our analysis node.\n    audioSource.connect(node);\n\n    // Connect our analysis node to the output. Required even though we do not\n    // output any audio. Allows further downstream audio processing or output to\n    // occur.\n    node.connect(context.destination);\n  } catch (err) {\n    throw new Error(\n      `Failed to load audio analyzer WASM module. Further info: ${err.message}`\n    );\n  }\n\n  return { context, node };\n}\n","import React from 'react';\nimport Radio from '@material-ui/core/Radio';\nimport FormControlLabel from '@material-ui/core/FormControlLabel';\n\n        {/* <div>\n          <String name='E2' />\n          <String name='A2' />\n          <String name='D3' />\n          <String name='G3' />\n          <String name='B3' />\n          <String name='E4' />\n        </div> */}\n\nexport default function StringSelector() {\n  const [selectedValue, setSelectedValue] = React.useState('E2');\n\n  const handleChange = (event) => {\n    alert(`selected ${event.target.value}`)\n    setSelectedValue(event.target.value);\n  };\n\n  return (\n    <div>\n      <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'E2'}\n            onChange={handleChange}\n            value=\"E2\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'E2' }}\n          />}\n        label=\"E2\"\n        labelPlacement=\"top\"\n      />\n      <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'A2'}\n            onChange={handleChange}\n            value=\"A2\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'A2' }}\n          />}\n        label=\"A2\"\n        labelPlacement=\"top\"\n      />\n      <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'D3'}\n            onChange={handleChange}\n            value=\"D3\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'D3' }}\n          />}\n        label=\"D3\"\n        labelPlacement=\"top\"\n      />\n      <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'G3'}\n            onChange={handleChange}\n            value=\"G3\"\n            color=\"default\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'G3' }}\n          />}\n          label=\"G3\"\n          labelPlacement=\"top\"\n        />\n        <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'B3'}\n            onChange={handleChange}\n            value=\"B3\"\n            color=\"default\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'B3' }}\n          />}\n          label=\"B3\"\n          labelPlacement=\"top\"\n        />\n        <FormControlLabel\n          value=\"top\"\n          control={<Radio\n            checked={selectedValue === 'E4'}\n            onChange={handleChange}\n            value=\"E4\"\n            color=\"default\"\n            name=\"radio-button-string\"\n            inputProps={{ 'aria-label': 'E4' }}\n          />}\n          label=\"E4\"\n          labelPlacement=\"top\"\n        />\n    </div>\n  );\n}\n","import React from 'react';\nimport { RadialGauge } from \"react-canvas-gauges\"\n\n\n/**\n * # standard tuning:\n * E2\t82.41\n * A2\t110.00\n * D3\t146.83\n * G3\t196.00\n * B3\t246.94\n * E4\t329.63\n */\n\n\n// const fq = {\n//   'E2': ['77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87'],\n//   'A2': [],\n//   'D3': [],\n//   'G3': [],\n//   'B3': [],\n//   'E4': [],\n\n// }\n\nexport default class PitchReadout extends React.Component {\n\n    render() {\n        return (\n        <RadialGauge\n            units='Hz'\n            title='Frequency'\n            value={this.props.latestPitch\n            ? `${this.props.latestPitch.toFixed(1)}`\n            : this.props.running\n            ? '82'\n            : '0'}\n            minValue={77}\n            maxValue={87}\n            majorTicks={['77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87']}\n            minorTicks={2}\n            strokeTicks={true}\n            highlights={[\n            {\"from\": 77, \"to\": 82, \"color\": \"rgba(0,0, 255, .3)\"},\n            {\"from\": 82, \"to\": 87, \"color\": \"rgba(255, 0, 0, .3)\"}\n            ]}\n            width={400}\n            height={400}\n        ></RadialGauge>    \n        );\n    }\n}\n  \n  ","import React from \"react\";\nimport \"./App.css\";\nimport { setupAudio } from \"./setupAudio\";\nimport { RadialGauge } from \"react-canvas-gauges\"\nimport Button from '@material-ui/core/Button';\nimport Grid from '@material-ui/core/Grid';\nimport { StringSelector } from \"./components\";\nimport { PitchReadout } from \"./components\";\n\n\nfunction AudioRecorderControl() {\n  const [audio, setAudio] = React.useState(undefined);\n  const [running, setRunning] = React.useState(false);\n  const [latestPitch, setLatestPitch] = React.useState(undefined);\n\n  // Initial state. Initialize the web audio once a user gesture on the page\n  // has been registered.\n  if (!audio) {\n    return (\n      <button\n        onClick={async () => {\n          setAudio(await setupAudio(setLatestPitch));\n          setRunning(true);\n        }}\n      >\n        Tune Your Guitar or Bass\n      </button>\n    );\n  }\n\n  // Audio already initialized. Suspend / resume based on its current state.\n  const { context } = audio;\n  return (\n    <Grid container direction=\"column\">\n      <Grid>\n        A4 = 440hz\n      </Grid>\n\n      <Grid>\n        <PitchReadout running={running} latestPitch={latestPitch} />\n      </Grid>\n\n      <Grid>\n        <StringSelector instrument='guitar' tuning='standard' /> \n      </Grid>\n\n      <Grid>\n        <Button\n          onClick={async () => {\n            if (running) {\n              await context.suspend();\n              setRunning(context.state === \"running\");\n            } else {\n              await context.resume();\n              setRunning(context.state === \"running\");\n            }\n          }}\n          disabled={context.state !== \"running\" && context.state !== \"suspended\"}\n        >\n          {running ? \"Pause\" : \"Resume\"}\n        </Button>\n      </Grid>\n    </Grid>\n  );\n}\n\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <div className=\"App-content\">\n        <AudioRecorderControl />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}